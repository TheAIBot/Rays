@page "/"
@using Blazor.Extensions
@using Rays
@using System.Numerics
@using System.Diagnostics.CodeAnalysis
@using Rays.Polygons
@using Rays.Scenes;
@using System.Diagnostics;
@implements IAsyncDisposable


<BECanvas Width="@((int)_CanvasSize.X)" Height="@((int)_CanvasSize.Y)" @ref="CanvasReference"></BECanvas>

@code {
    private readonly Vector2 _CanvasSize = new Vector2(300, 400);
    private readonly CancellationTokenSource _cancellationTokenSource = new();
    private Task? _renderTask;

    [AllowNull]
    protected BECanvasComponent CanvasReference;
    [Inject]
    private ISceneFactory sceneFactory { get; set; } = default!;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            var canvas = await CanvasReference.CreateCanvas2DAsync();
            var drawer = new CanvasPolygonDrawer(canvas, _CanvasSize);
            IScene scene = sceneFactory.Create(drawer);

            _renderTask = Task.Factory.StartNew(async () =>
            {
                var watch = new Stopwatch();
                try
                {
                    using var timer = new PeriodicTimer(TimeSpan.FromMilliseconds(50));
                    while (await timer.WaitForNextTickAsync(_cancellationTokenSource.Token))
                    {
                        watch.Restart();
                        await scene.RenderAsync();
                        watch.Stop();
                        Console.WriteLine($"Time: {watch.ElapsedMilliseconds:N2}");
                    }
                }
                catch (Exception e)
                {
                    Console.WriteLine(e);
                    throw;
                }
            }, TaskCreationOptions.LongRunning);
        }
    }

    public async ValueTask DisposeAsync()
    {
        _cancellationTokenSource.Cancel();
        if (_renderTask != null)
        {
            await _renderTask;
        }
    }
}