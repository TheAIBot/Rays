@page "/"
@using Blazor.Extensions
@using Rays
@using System.Numerics
@using System.Diagnostics.CodeAnalysis
@using Rays.Polygons
@using Rays.Scenes;
@using System.Diagnostics;
@implements IAsyncDisposable

<div @ref="_divRef" @onkeydown="HandleKeyPress" 
     style="width: 100%; height: 100%;" tabindex="0">
    <img id="image"
         draggable="false"
         @ondragstart="@(e => Task.FromResult(false))"
         @onpointerdown="StartDrag"
         @onpointerup="EndDrag"
         @onpointermove="Drag"
         width="@(_CanvasSize.X)"
         height="@(_CanvasSize.Y)" />
</div>

@code {
    private readonly Point _CanvasSize = new Point(900, 1200);
    private readonly CancellationTokenSource _cancellationTokenSource = new();
    private Task? _renderTask;
    private I3DScene? _scene;

    private ElementReference _divRef;
    private float _step = 5;
    private bool _dragging = false;
    private Vector2 _initialMousePosition = new Vector2();

    [Parameter]
    public SceneSettings SceneSettings { get; set; } = default!;

    [Inject]
    private ILogger<Index> _logger { get; set; } = default!;

    [Inject]
    private IJSRuntime _jsRuntime { get; set; } = default!;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await _divRef.FocusAsync();

            var drawer = new BrowserImageDrawer(_CanvasSize / 4, _jsRuntime);
            I3DScene scene = SceneSettings.SceneFactory.Create(SceneSettings.TriangleSetIntersectorFactory.Create(SceneSettings.GeometryModel.ModelFileName), drawer);
            _scene = scene;

            _renderTask = Task.Factory.StartNew(async () =>
            {
                var watch = new Stopwatch();
                try
                {
                    scene.Camera.Position = new Vector3(500, 500, 500);
                    scene.Camera.Direction = Vector3.Normalize(-scene.Camera.Position);
                    using var timer = new PeriodicTimer(TimeSpan.FromMilliseconds(50));
                    while (await timer.WaitForNextTickAsync(_cancellationTokenSource.Token))
                    {
                        watch.Restart();
                        await scene.RenderAsync(_cancellationTokenSource.Token);
                        watch.Stop();

                        _logger.LogInformation($"Time: {watch.ElapsedMilliseconds:N2}");
                    }
                }
                catch (TaskCanceledException)
                {
                    _logger.LogInformation("Ended renderer");
                }
                catch (Exception e)
                {
                    _logger.LogError(e, "Unexpected error");
                    throw;
                }
            }, TaskCreationOptions.LongRunning);
        }

        await base.OnAfterRenderAsync(firstRender);
    }

    private void HandleKeyPress(KeyboardEventArgs e)
    {
        if (_scene == null)
        {
            return;
        }

        var rightDirection = Vector3.Cross(_scene.Camera.Direction, _scene.Camera.UpDirection);
        switch (e.Key.ToLower())
        {
            case "w":
                _scene.Camera.Position += _scene.Camera.Direction * _step;
                break;
            case "s":
                _scene.Camera.Position -= _scene.Camera.Direction * _step;
                break;
            case "a":
                _scene.Camera.Position -= rightDirection * _step;
                break;
            case "d":
                _scene.Camera.Position += rightDirection * _step;
                break;
        }
    }

    private void StartDrag(PointerEventArgs e)
    {
        _dragging = true;
        _initialMousePosition = new Vector2((float)e.ClientX, (float)e.ClientY);
    }

    private void EndDrag(PointerEventArgs e)
    {
        _dragging = false;
    }

    private void Drag(PointerEventArgs e)
    {
        if (_scene == null)
        {
            return;
        }

        if (_dragging)
        {
            Vector2 currentMousePosition = new Vector2((float)e.ClientX, (float)e.ClientY);
            Vector2 mouseDelta = currentMousePosition - _initialMousePosition;

            // scale factor for mouse sensitivity
            float scale = 0.01f; // you may want to adjust this
            mouseDelta *= scale;

            // calculate rotation quaternions
            var rightDirection = Vector3.Cross(_scene.Camera.Direction, _scene.Camera.UpDirection);
            Quaternion pitchRotation = Quaternion.CreateFromAxisAngle(rightDirection, -mouseDelta.Y);
            Quaternion yawRotation = Quaternion.CreateFromAxisAngle(_scene.Camera.UpDirection, mouseDelta.X);
            Quaternion rotation = Quaternion.Multiply(pitchRotation, yawRotation);

            // rotate the camera direction and up direction
            _scene.Camera.Direction = Vector3.Normalize(Vector3.Transform(_scene.Camera.Direction, rotation));
            // _scene.Camera.UpDirection = Vector3.Normalize(Vector3.Transform(_scene.Camera.UpDirection, rotation));

            // reset the initial mouse position for the next frame
            _initialMousePosition = currentMousePosition;
        }
    }

    public async ValueTask DisposeAsync()
    {
        _cancellationTokenSource.Cancel();
        if (_renderTask != null)
        {
            await _renderTask;
        }
    }
}