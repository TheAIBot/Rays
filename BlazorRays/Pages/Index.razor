@page "/"
@using Blazor.Extensions
@using Rays
@using System.Numerics
@using System.Diagnostics.CodeAnalysis
@using Rays.Polygons
@using Rays.Scenes;
@using System.Diagnostics;
@using Rays._3D;
@implements IAsyncDisposable

<div @ref="_divRef" @onkeydown="HandleKeyPress" 
     style="width: 100%; height: 100%;" tabindex="0">
    <img id="image"
         draggable="false"
         @ondragstart="@(e => Task.FromResult(false))"
         @onpointerdown="StartDrag"
         @onpointerup="EndDrag"
         @onpointermove="Drag"
         width="@(_CanvasSize.X)"
         height="@(_CanvasSize.Y)" />
</div>

<div class="statistics-group">
    <h3>Statistics</h3>
    <table>
        <thead>
            <tr>
                <th class="left">Statistic</th>
                <th class="numeric">Min</th>
                <th class="numeric">Average</th>
                <th class="numeric">Max</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td class="left">Frame Time:</td>
                <td class="numeric">@_frameTime.Min.ToString("N1")</td>
                <td class="numeric">@_frameTime.Average.ToString("N1")</td>
                <td class="numeric">@_frameTime.Max.ToString("N1")</td>
            </tr>
            <tr>
                <td class="left">Nodes Traversed:</td>
                <td class="numeric">@_statistics.NodesTraversed.Min.ToString("N1")</td>
                <td class="numeric">@_statistics.NodesTraversed.Average.ToString("N1")</td>
                <td class="numeric">@_statistics.NodesTraversed.Max.ToString("N1")</td>
            </tr>
            <tr>
                <td class="left">Triangles Checked:</td>
                <td class="numeric">@_statistics.TrianglesChecked.Min.ToString("N1")</td>
                <td class="numeric">@_statistics.TrianglesChecked.Average.ToString("N1")</td>
                <td class="numeric">@_statistics.TrianglesChecked.Max.ToString("N1")</td>
            </tr>
            <tr>
                <td class="left">Intersections Found:</td>
                <td class="numeric">@_statistics.IntersectionsFound.Min.ToString("N1")</td>
                <td class="numeric">@_statistics.IntersectionsFound.Average.ToString("N1")</td>
                <td class="numeric">@_statistics.IntersectionsFound.Max.ToString("N1")</td>
            </tr>
        </tbody>
    </table>
</div>

@code {
    private readonly Point _CanvasSize = new Point(1200, 900);
    private readonly CancellationTokenSource _cancellationTokenSource = new();
    private Task? _renderTask;
    private I3DScene? _scene;

    private ElementReference _divRef;
    private float _step = 5;
    private bool _dragging = false;
    private Vector2 _initialMousePosition = new Vector2();

    private readonly HistoricalStatistics<long> _frameTime = new HistoricalStatistics<long>(20);

    [Parameter]
    public SceneSettings SceneSettings { get; set; } = default!;

    [Inject]
    private ILogger<Index> _logger { get; set; } = default!;

    [Inject]
    private IJSRuntime _jsRuntime { get; set; } = default!;

    [Inject]
    private CombinedTriangleTreeStatistics _statistics { get; set; } = default!;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await _divRef.FocusAsync();

            var drawer = new BrowserImageDrawer(_CanvasSize / 2, _jsRuntime);
            I3DScene scene = SceneSettings.SceneFactory.Create(SceneSettings.TriangleSetIntersectorFactory.Create(SceneSettings.GeometryModel.ModelFileName), drawer);
            _scene = scene;
            _step = Vector3.Distance(Vector3.Zero, _scene.Information.BoundingBox.Size) / 100.0f;

            _renderTask = Task.Factory.StartNew(async () =>
            {
                var watch = new Stopwatch();
                try
                {

                    using var timer = new PeriodicTimer(TimeSpan.FromMilliseconds(50));
                    while (await timer.WaitForNextTickAsync(_cancellationTokenSource.Token))
                    {
                        watch.Restart();
                        await scene.RenderAsync(_cancellationTokenSource.Token);
                        watch.Stop();

                        _frameTime.AddNewEntry();
                        _frameTime.UpdateLatestEntry(watch.ElapsedMilliseconds);

                        _statistics.ProcessStatistics();
                        await InvokeAsync(() => StateHasChanged());
                    }
                }
                catch (OperationCanceledException)
                {
                    _logger.LogInformation("Ended renderer");
                }
                catch (Exception e)
                {
                    _logger.LogError(e, "Unexpected error");
                    throw;
                }
            }, TaskCreationOptions.LongRunning);
        }

        await base.OnAfterRenderAsync(firstRender);
    }

    private void HandleKeyPress(KeyboardEventArgs e)
    {
        if (_scene == null)
        {
            return;
        }

        var rightDirection = Vector3.Cross(_scene.Camera.Direction, _scene.Camera.UpDirection);
        switch (e.Key.ToLower())
        {
            case "w":
                _scene.Camera.Position += _scene.Camera.Direction * _step;
                break;
            case "s":
                _scene.Camera.Position -= _scene.Camera.Direction * _step;
                break;
            case "a":
                _scene.Camera.Position -= rightDirection * _step;
                break;
            case "d":
                _scene.Camera.Position += rightDirection * _step;
                break;
        }
    }

    private void StartDrag(PointerEventArgs e)
    {
        _dragging = true;
        _initialMousePosition = new Vector2((float)e.ClientX, (float)e.ClientY);
    }

    private void EndDrag(PointerEventArgs e)
    {
        _dragging = false;
    }

    private void Drag(PointerEventArgs e)
    {
        if (_scene == null)
        {
            return;
        }

        if (_dragging)
        {
            Vector2 currentMousePosition = new Vector2((float)e.ClientX, (float)e.ClientY);
            Vector2 mouseDelta = currentMousePosition - _initialMousePosition;

            // scale factor for mouse sensitivity
            float scale = 0.01f; // you may want to adjust this
            mouseDelta *= scale;

            // calculate rotation quaternions
            var rightDirection = Vector3.Cross(_scene.Camera.Direction, _scene.Camera.UpDirection);
            Quaternion pitchRotation = Quaternion.CreateFromAxisAngle(rightDirection, -mouseDelta.Y);
            Quaternion yawRotation = Quaternion.CreateFromAxisAngle(_scene.Camera.UpDirection, mouseDelta.X);
            Quaternion rotation = Quaternion.Multiply(pitchRotation, yawRotation);

            // rotate the camera direction and up direction
            _scene.Camera.Direction = Vector3.Normalize(Vector3.Transform(_scene.Camera.Direction, rotation));
            // _scene.Camera.UpDirection = Vector3.Normalize(Vector3.Transform(_scene.Camera.UpDirection, rotation));

            // reset the initial mouse position for the next frame
            _initialMousePosition = currentMousePosition;
        }
    }

    public async ValueTask DisposeAsync()
    {
        _cancellationTokenSource.Cancel();
        if (_renderTask != null)
        {
            await _renderTask;
        }
    }
}